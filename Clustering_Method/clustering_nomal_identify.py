# Identify nomal clusters and anomalous clusters with nomal data
# Input 'data' is initial data

import numpy as np
# from utils.class_row import nomal_class_data

# Change function signature:
# data_features_for_clustering: NumPy array of features used for clustering (e.g. X_reduced, shape (N, num_pca_features))
# original_labels_aligned: Original labels for each row in data_features_for_clustering (0 or 1, shape (N,))
# clusters_assigned: Cluster IDs assigned to each row in data_features_for_clustering (shape (N,))
# num_total_clusters: Total number of clusters generated by the clustering algorithm
def clustering_nomal_identify(data_features_for_clustering, original_labels_aligned, clusters_assigned, num_total_clusters):
    
    print(f"\n[DEBUG CNI] Received 'data_features_for_clustering' - Shape: {data_features_for_clustering.shape}")
    if data_features_for_clustering.ndim == 2 and data_features_for_clustering.shape[0] > 0:
        print(f"[DEBUG CNI]   NumPy array - First 5 cols of first row: {data_features_for_clustering[0, :min(5, data_features_for_clustering.shape[1])] if data_features_for_clustering.shape[1] > 0 else '0 cols'}")
    print(f"[DEBUG CNI] Received 'original_labels_aligned' - Shape: {original_labels_aligned.shape}, Unique values: {np.unique(original_labels_aligned, return_counts=True)}")
    print(f"[DEBUG CNI] Received 'clusters_assigned' - Shape: {clusters_assigned.shape}, Unique values: {np.unique(clusters_assigned, return_counts=True)}")
    print(f"[DEBUG CNI] Received 'num_total_clusters': {num_total_clusters}")

    # Extract normal samples (Label == 0) from the feature space used for clustering
    known_normal_samples_features = data_features_for_clustering[original_labels_aligned == 0]
    print(f"[DEBUG CNI] 'known_normal_samples_features' (from X_reduced space) - Shape: {known_normal_samples_features.shape}")
    if known_normal_samples_features.ndim == 2 and known_normal_samples_features.shape[0] > 0:
         print(f"[DEBUG CNI]   NumPy array - First 5 cols of first row: {known_normal_samples_features[0, :min(5, known_normal_samples_features.shape[1])] if known_normal_samples_features.shape[1] > 0 else '0 cols'}")

    # final_labels will have the same length as data_features_for_clustering and clusters_assigned
    final_labels = np.zeros(len(data_features_for_clustering), dtype=int) 
    threshold = 0.3

    for cluster_id in range(num_total_clusters):
        cluster_mask = (clusters_assigned == cluster_id)

        if not np.any(cluster_mask):
            # print(f"[INFO CNI] Cluster {cluster_id} is empty. Skipping.")
            continue

        current_cluster_features = data_features_for_clustering[cluster_mask]
        # print(f"[DEBUG CNI] 'current_cluster_features' (cluster_id {cluster_id}, from X_reduced space) - Shape: {current_cluster_features.shape}")

        if current_cluster_features.size == 0 or known_normal_samples_features.size == 0:
            num_normal_in_cluster = 0
        else:
            try:
                comparison_matrix = (current_cluster_features[:, None, :] == known_normal_samples_features[None, :, :])
                all_features_match = np.all(comparison_matrix, axis=2)
                any_known_normal_matches = np.any(all_features_match, axis=1)
                num_normal_in_cluster = np.sum(any_known_normal_matches)
                
            except ValueError as e:
                print(f"[Error CNI comparing cluster {cluster_id}] shape mismatch or other ValueError: {e}")
                print(f"  Cluster features shape: {current_cluster_features.shape}, Known normal features shape: {known_normal_samples_features.shape}")
                num_normal_in_cluster = 0
            except MemoryError as me: 
                print(f"[Error CNI comparing cluster {cluster_id}] MemoryError: {me}")
                print(f"  Could not perform comparison due to memory constraints. Treating as 0 normal samples for this cluster.")
                num_normal_in_cluster = 0
    
        normal_ratio = num_normal_in_cluster / len(current_cluster_features) if len(current_cluster_features) > 0 else 0
            
        label_for_final_output = 0 if normal_ratio >= threshold else 1
        final_labels[cluster_mask] = label_for_final_output

    return final_labels